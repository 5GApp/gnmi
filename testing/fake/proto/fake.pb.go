// Code generated by protoc-gen-go.
// source: fake.proto
// DO NOT EDIT!

/*
Package telemetry_proxy_fake is a generated protocol buffer package.

It is generated from these files:
	fake.proto

It has these top-level messages:
	Configuration
	Credentials
	Config
	DeleteValue
	Value
	Timestamp
	IntValue
	IntRange
	IntList
	DoubleValue
	DoubleRange
	DoubleList
	StringValue
	StringList
*/
package telemetry_proxy_fake

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type State int32

const (
	State_STOPPED State = 0
	State_INIT    State = 1
	State_RUNNING State = 2
)

var State_name = map[int32]string{
	0: "STOPPED",
	1: "INIT",
	2: "RUNNING",
}
var State_value = map[string]int32{
	"STOPPED": 0,
	"INIT":    1,
	"RUNNING": 2,
}

func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}
func (State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Config_ClientType int32

const (
	Config_GRPC           Config_ClientType = 0
	Config_STUBBY         Config_ClientType = 1
	Config_GRPC_GNMI      Config_ClientType = 2
	Config_GRPC_GNMI_PROD Config_ClientType = 3
)

var Config_ClientType_name = map[int32]string{
	0: "GRPC",
	1: "STUBBY",
	2: "GRPC_GNMI",
	3: "GRPC_GNMI_PROD",
}
var Config_ClientType_value = map[string]int32{
	"GRPC":           0,
	"STUBBY":         1,
	"GRPC_GNMI":      2,
	"GRPC_GNMI_PROD": 3,
}

func (x Config_ClientType) String() string {
	return proto.EnumName(Config_ClientType_name, int32(x))
}
func (Config_ClientType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

// Configuration is used to store all agent configuration for the fake agent
// server.  Each config describes a single agent hosted on the server.
type Configuration struct {
	// Repeated list of targets to emulate.
	Config []*Config `protobuf:"bytes,1,rep,name=config" json:"config,omitempty"`
}

func (m *Configuration) Reset()                    { *m = Configuration{} }
func (m *Configuration) String() string            { return proto.CompactTextString(m) }
func (*Configuration) ProtoMessage()               {}
func (*Configuration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Configuration) GetConfig() []*Config {
	if m != nil {
		return m.Config
	}
	return nil
}

type Credentials struct {
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *Credentials) Reset()                    { *m = Credentials{} }
func (m *Credentials) String() string            { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()               {}
func (*Credentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Credentials) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Credentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// Config is a collection of values that together represent the update streams
// for one or more fake devices.
type Config struct {
	// The target for which the fake will publish values for.
	Target string `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	// Port for the agent to listen on. If 0 or unset the agent will pick a port
	// for this agent.
	Port int64 `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	// A global random seed used in generating subsequent values. Set to have
	// reproducible results.
	Seed int64 `protobuf:"varint,6,opt,name=seed" json:"seed,omitempty"`
	// The list of values generated.  Each value will contain its corresponding
	// target as the first string in the event.GetValue().path meaning that it is
	// possible to generate streams that will be rejected by the cache for testing
	// purposes.
	Values []*Value `protobuf:"bytes,3,rep,name=values" json:"values,omitempty"`
	// Setting disable sync will keep the configured client from autogenerating a
	// sync message. This allows negative testing on sync handling.
	DisableSync bool `protobuf:"varint,4,opt,name=disable_sync,json=disableSync" json:"disable_sync,omitempty"`
	// Type of client to fake either Stubby or GRPC based fake.
	ClientType Config_ClientType `protobuf:"varint,5,opt,name=client_type,json=clientType,enum=telemetry.proxy.fake.Config_ClientType" json:"client_type,omitempty"`
	// Disable EOF will hold open the subscription and not automagically close
	// the stream once the value queue is empty.
	DisableEof bool `protobuf:"varint,7,opt,name=disable_eof,json=disableEof" json:"disable_eof,omitempty"`
	// Per RPC credentials for the agent. If not set no per RPC auth will be used.
	Credentials *Credentials `protobuf:"bytes,8,opt,name=credentials" json:"credentials,omitempty"`
	// TLS cert for use on the agent. If not set the transport will not be TLS.
	Cert []byte `protobuf:"bytes,9,opt,name=cert,proto3" json:"cert,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Config) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *Config) GetPort() int64 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Config) GetSeed() int64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *Config) GetValues() []*Value {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *Config) GetDisableSync() bool {
	if m != nil {
		return m.DisableSync
	}
	return false
}

func (m *Config) GetClientType() Config_ClientType {
	if m != nil {
		return m.ClientType
	}
	return Config_GRPC
}

func (m *Config) GetDisableEof() bool {
	if m != nil {
		return m.DisableEof
	}
	return false
}

func (m *Config) GetCredentials() *Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *Config) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

// Delete will cause the value to be deleted at the Value's path.
type DeleteValue struct {
}

func (m *DeleteValue) Reset()                    { *m = DeleteValue{} }
func (m *DeleteValue) String() string            { return proto.CompactTextString(m) }
func (*DeleteValue) ProtoMessage()               {}
func (*DeleteValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// Value is the main message that will trigger a stream of updates for a given
// path.  A file containing a list of values can be used to simulate a network
// device for integration tests.
type Value struct {
	// The device specific, or OpenConfig path corresponding to a value.
	Path []string `protobuf:"bytes,1,rep,name=path" json:"path,omitempty"`
	// The initial timestamp and configuration on how the timestamp will change
	// for subsequent values. If timestamp is not set the default will assume to
	// be the current system time.
	Timestamp *Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// If set, repeat indicates that the value should be repeated this many times,
	// otherwise it is repeated indefinitely.
	Repeat int32 `protobuf:"varint,6,opt,name=repeat" json:"repeat,omitempty"`
	// A local random seed used in generating subsequent values for this path. If
	// not set, will share the global random source with seed defined in Config.
	Seed int64 `protobuf:"varint,7,opt,name=seed" json:"seed,omitempty"`
	// The initial value of the chosen type including configuration on how the
	// value will mutate for subsequent updates.
	//
	// Types that are valid to be assigned to Value:
	//	*Value_IntValue
	//	*Value_DoubleValue
	//	*Value_StringValue
	//	*Value_Sync
	//	*Value_Delete
	Value isValue_Value `protobuf_oneof:"value"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isValue_Value interface {
	isValue_Value()
}

type Value_IntValue struct {
	IntValue *IntValue `protobuf:"bytes,100,opt,name=int_value,json=intValue,oneof"`
}
type Value_DoubleValue struct {
	DoubleValue *DoubleValue `protobuf:"bytes,101,opt,name=double_value,json=doubleValue,oneof"`
}
type Value_StringValue struct {
	StringValue *StringValue `protobuf:"bytes,102,opt,name=string_value,json=stringValue,oneof"`
}
type Value_Sync struct {
	Sync uint64 `protobuf:"varint,103,opt,name=sync,oneof"`
}
type Value_Delete struct {
	Delete *DeleteValue `protobuf:"bytes,104,opt,name=delete,oneof"`
}

func (*Value_IntValue) isValue_Value()    {}
func (*Value_DoubleValue) isValue_Value() {}
func (*Value_StringValue) isValue_Value() {}
func (*Value_Sync) isValue_Value()        {}
func (*Value_Delete) isValue_Value()      {}

func (m *Value) GetValue() isValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetPath() []string {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Value) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Value) GetRepeat() int32 {
	if m != nil {
		return m.Repeat
	}
	return 0
}

func (m *Value) GetSeed() int64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *Value) GetIntValue() *IntValue {
	if x, ok := m.GetValue().(*Value_IntValue); ok {
		return x.IntValue
	}
	return nil
}

func (m *Value) GetDoubleValue() *DoubleValue {
	if x, ok := m.GetValue().(*Value_DoubleValue); ok {
		return x.DoubleValue
	}
	return nil
}

func (m *Value) GetStringValue() *StringValue {
	if x, ok := m.GetValue().(*Value_StringValue); ok {
		return x.StringValue
	}
	return nil
}

func (m *Value) GetSync() uint64 {
	if x, ok := m.GetValue().(*Value_Sync); ok {
		return x.Sync
	}
	return 0
}

func (m *Value) GetDelete() *DeleteValue {
	if x, ok := m.GetValue().(*Value_Delete); ok {
		return x.Delete
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Value) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Value_OneofMarshaler, _Value_OneofUnmarshaler, _Value_OneofSizer, []interface{}{
		(*Value_IntValue)(nil),
		(*Value_DoubleValue)(nil),
		(*Value_StringValue)(nil),
		(*Value_Sync)(nil),
		(*Value_Delete)(nil),
	}
}

func _Value_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Value)
	// value
	switch x := m.Value.(type) {
	case *Value_IntValue:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IntValue); err != nil {
			return err
		}
	case *Value_DoubleValue:
		b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DoubleValue); err != nil {
			return err
		}
	case *Value_StringValue:
		b.EncodeVarint(102<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringValue); err != nil {
			return err
		}
	case *Value_Sync:
		b.EncodeVarint(103<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Sync))
	case *Value_Delete:
		b.EncodeVarint(104<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Delete); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Value.Value has unexpected type %T", x)
	}
	return nil
}

func _Value_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Value)
	switch tag {
	case 100: // value.int_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IntValue)
		err := b.DecodeMessage(msg)
		m.Value = &Value_IntValue{msg}
		return true, err
	case 101: // value.double_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DoubleValue)
		err := b.DecodeMessage(msg)
		m.Value = &Value_DoubleValue{msg}
		return true, err
	case 102: // value.string_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringValue)
		err := b.DecodeMessage(msg)
		m.Value = &Value_StringValue{msg}
		return true, err
	case 103: // value.sync
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Value_Sync{x}
		return true, err
	case 104: // value.delete
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeleteValue)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Delete{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Value_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Value)
	// value
	switch x := m.Value.(type) {
	case *Value_IntValue:
		s := proto.Size(x.IntValue)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Value_DoubleValue:
		s := proto.Size(x.DoubleValue)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Value_StringValue:
		s := proto.Size(x.StringValue)
		n += proto.SizeVarint(102<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Value_Sync:
		n += proto.SizeVarint(103<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Sync))
	case *Value_Delete:
		s := proto.Size(x.Delete)
		n += proto.SizeVarint(104<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Timestamp struct {
	// Initial timestamp for the corresponding value, nanoseconds since epoch.
	// This value need have no relation to absolute real-time as the stream of
	// of updates is generated without regard to the real clock and can be run
	// repeatably at any time if the seed is set in the corresponding Value.
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// These values will vary the change in the timestamp for subsequent outputs
	// by a value between delta_min and delta_max.  Set to the same value to force
	// a set periodic interval.
	DeltaMin int64 `protobuf:"varint,2,opt,name=delta_min,json=deltaMin" json:"delta_min,omitempty"`
	DeltaMax int64 `protobuf:"varint,3,opt,name=delta_max,json=deltaMax" json:"delta_max,omitempty"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (m *Timestamp) String() string            { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Timestamp) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Timestamp) GetDeltaMin() int64 {
	if m != nil {
		return m.DeltaMin
	}
	return 0
}

func (m *Timestamp) GetDeltaMax() int64 {
	if m != nil {
		return m.DeltaMax
	}
	return 0
}

type IntValue struct {
	// If distribution is IntRange, value is used as the initial value
	// inside [minimum, maximum] and hold the value as it mutates.
	// If distribution is IntList, value is only used to hold the value as it
	// mutates.
	// If no distribution is set, value is used as it mutates, i.e. constant
	// update.
	Value int64 `protobuf:"varint,1,opt,name=value" json:"value,omitempty"`
	// Types that are valid to be assigned to Distribution:
	//	*IntValue_Range
	//	*IntValue_List
	Distribution isIntValue_Distribution `protobuf_oneof:"distribution"`
}

func (m *IntValue) Reset()                    { *m = IntValue{} }
func (m *IntValue) String() string            { return proto.CompactTextString(m) }
func (*IntValue) ProtoMessage()               {}
func (*IntValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isIntValue_Distribution interface {
	isIntValue_Distribution()
}

type IntValue_Range struct {
	Range *IntRange `protobuf:"bytes,2,opt,name=range,oneof"`
}
type IntValue_List struct {
	List *IntList `protobuf:"bytes,3,opt,name=list,oneof"`
}

func (*IntValue_Range) isIntValue_Distribution() {}
func (*IntValue_List) isIntValue_Distribution()  {}

func (m *IntValue) GetDistribution() isIntValue_Distribution {
	if m != nil {
		return m.Distribution
	}
	return nil
}

func (m *IntValue) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *IntValue) GetRange() *IntRange {
	if x, ok := m.GetDistribution().(*IntValue_Range); ok {
		return x.Range
	}
	return nil
}

func (m *IntValue) GetList() *IntList {
	if x, ok := m.GetDistribution().(*IntValue_List); ok {
		return x.List
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IntValue) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IntValue_OneofMarshaler, _IntValue_OneofUnmarshaler, _IntValue_OneofSizer, []interface{}{
		(*IntValue_Range)(nil),
		(*IntValue_List)(nil),
	}
}

func _IntValue_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IntValue)
	// distribution
	switch x := m.Distribution.(type) {
	case *IntValue_Range:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Range); err != nil {
			return err
		}
	case *IntValue_List:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.List); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IntValue.Distribution has unexpected type %T", x)
	}
	return nil
}

func _IntValue_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IntValue)
	switch tag {
	case 2: // distribution.range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IntRange)
		err := b.DecodeMessage(msg)
		m.Distribution = &IntValue_Range{msg}
		return true, err
	case 3: // distribution.list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IntList)
		err := b.DecodeMessage(msg)
		m.Distribution = &IntValue_List{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IntValue_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IntValue)
	// distribution
	switch x := m.Distribution.(type) {
	case *IntValue_Range:
		s := proto.Size(x.Range)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IntValue_List:
		s := proto.Size(x.List)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type IntRange struct {
	// The range of the value allowed.
	Minimum int64 `protobuf:"varint,1,opt,name=minimum" json:"minimum,omitempty"`
	Maximum int64 `protobuf:"varint,2,opt,name=maximum" json:"maximum,omitempty"`
	// If set, the value is cumulative and the subsequent value is value + delta
	// where delta is randomly chosen between delta_min and delta_max.  The range
	// minimum and maximum are still respected and values will saturate at the
	// boundaries if they are exceeded. If not set subsequent value is a value
	// randomly chosen between minimum and maximum.
	DeltaMin int64 `protobuf:"varint,3,opt,name=delta_min,json=deltaMin" json:"delta_min,omitempty"`
	DeltaMax int64 `protobuf:"varint,4,opt,name=delta_max,json=deltaMax" json:"delta_max,omitempty"`
}

func (m *IntRange) Reset()                    { *m = IntRange{} }
func (m *IntRange) String() string            { return proto.CompactTextString(m) }
func (*IntRange) ProtoMessage()               {}
func (*IntRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *IntRange) GetMinimum() int64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *IntRange) GetMaximum() int64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *IntRange) GetDeltaMin() int64 {
	if m != nil {
		return m.DeltaMin
	}
	return 0
}

func (m *IntRange) GetDeltaMax() int64 {
	if m != nil {
		return m.DeltaMax
	}
	return 0
}

type IntList struct {
	// The set of values which can be used.
	Options []int64 `protobuf:"varint,1,rep,packed,name=options" json:"options,omitempty"`
	// Set to true to randomize selection of value from options. If false, the
	// values are cycled in order, starting at index 0.
	Random bool `protobuf:"varint,2,opt,name=random" json:"random,omitempty"`
}

func (m *IntList) Reset()                    { *m = IntList{} }
func (m *IntList) String() string            { return proto.CompactTextString(m) }
func (*IntList) ProtoMessage()               {}
func (*IntList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *IntList) GetOptions() []int64 {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *IntList) GetRandom() bool {
	if m != nil {
		return m.Random
	}
	return false
}

type DoubleValue struct {
	// If distribution is DoubleRange, value is used as the initial value
	// inside [minimum, maximum] and hold the value as it mutates.
	// If distribution is DoubleList, value is only used to hold the value as it
	// mutates.
	// If no distribution is set, value is used as it mutates, i.e. constant
	// update.
	Value float64 `protobuf:"fixed64,1,opt,name=value" json:"value,omitempty"`
	// Types that are valid to be assigned to Distribution:
	//	*DoubleValue_Range
	//	*DoubleValue_List
	Distribution isDoubleValue_Distribution `protobuf_oneof:"distribution"`
}

func (m *DoubleValue) Reset()                    { *m = DoubleValue{} }
func (m *DoubleValue) String() string            { return proto.CompactTextString(m) }
func (*DoubleValue) ProtoMessage()               {}
func (*DoubleValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isDoubleValue_Distribution interface {
	isDoubleValue_Distribution()
}

type DoubleValue_Range struct {
	Range *DoubleRange `protobuf:"bytes,2,opt,name=range,oneof"`
}
type DoubleValue_List struct {
	List *DoubleList `protobuf:"bytes,3,opt,name=list,oneof"`
}

func (*DoubleValue_Range) isDoubleValue_Distribution() {}
func (*DoubleValue_List) isDoubleValue_Distribution()  {}

func (m *DoubleValue) GetDistribution() isDoubleValue_Distribution {
	if m != nil {
		return m.Distribution
	}
	return nil
}

func (m *DoubleValue) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *DoubleValue) GetRange() *DoubleRange {
	if x, ok := m.GetDistribution().(*DoubleValue_Range); ok {
		return x.Range
	}
	return nil
}

func (m *DoubleValue) GetList() *DoubleList {
	if x, ok := m.GetDistribution().(*DoubleValue_List); ok {
		return x.List
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DoubleValue) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DoubleValue_OneofMarshaler, _DoubleValue_OneofUnmarshaler, _DoubleValue_OneofSizer, []interface{}{
		(*DoubleValue_Range)(nil),
		(*DoubleValue_List)(nil),
	}
}

func _DoubleValue_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DoubleValue)
	// distribution
	switch x := m.Distribution.(type) {
	case *DoubleValue_Range:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Range); err != nil {
			return err
		}
	case *DoubleValue_List:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.List); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DoubleValue.Distribution has unexpected type %T", x)
	}
	return nil
}

func _DoubleValue_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DoubleValue)
	switch tag {
	case 2: // distribution.range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DoubleRange)
		err := b.DecodeMessage(msg)
		m.Distribution = &DoubleValue_Range{msg}
		return true, err
	case 3: // distribution.list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DoubleList)
		err := b.DecodeMessage(msg)
		m.Distribution = &DoubleValue_List{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DoubleValue_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DoubleValue)
	// distribution
	switch x := m.Distribution.(type) {
	case *DoubleValue_Range:
		s := proto.Size(x.Range)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DoubleValue_List:
		s := proto.Size(x.List)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DoubleRange struct {
	// The range of the value allowed.
	Minimum float64 `protobuf:"fixed64,1,opt,name=minimum" json:"minimum,omitempty"`
	Maximum float64 `protobuf:"fixed64,2,opt,name=maximum" json:"maximum,omitempty"`
	// If set, the value is cumulative and the subsequent value is value + delta
	// where delta is randomly chosen between delta_min and delta_max. The range
	// minimum and maximum are still respected. If not set subsequent value is a
	// value randomly chosen between minimum and maximum.
	DeltaMin float64 `protobuf:"fixed64,3,opt,name=delta_min,json=deltaMin" json:"delta_min,omitempty"`
	DeltaMax float64 `protobuf:"fixed64,4,opt,name=delta_max,json=deltaMax" json:"delta_max,omitempty"`
}

func (m *DoubleRange) Reset()                    { *m = DoubleRange{} }
func (m *DoubleRange) String() string            { return proto.CompactTextString(m) }
func (*DoubleRange) ProtoMessage()               {}
func (*DoubleRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DoubleRange) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *DoubleRange) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *DoubleRange) GetDeltaMin() float64 {
	if m != nil {
		return m.DeltaMin
	}
	return 0
}

func (m *DoubleRange) GetDeltaMax() float64 {
	if m != nil {
		return m.DeltaMax
	}
	return 0
}

type DoubleList struct {
	// The set of values which can be used.
	Options []float64 `protobuf:"fixed64,1,rep,packed,name=options" json:"options,omitempty"`
	// Set to true to randomize selection of value from options. If false, the
	// values are cycled in order.
	Random bool `protobuf:"varint,2,opt,name=random" json:"random,omitempty"`
}

func (m *DoubleList) Reset()                    { *m = DoubleList{} }
func (m *DoubleList) String() string            { return proto.CompactTextString(m) }
func (*DoubleList) ProtoMessage()               {}
func (*DoubleList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DoubleList) GetOptions() []float64 {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *DoubleList) GetRandom() bool {
	if m != nil {
		return m.Random
	}
	return false
}

type StringValue struct {
	// If distribution is StringList, value is used to hold the value as it
	// mutates.
	// If no distribution is set, value is used as it mutates, i.e. constant
	// update.
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	// Types that are valid to be assigned to Distribution:
	//	*StringValue_List
	Distribution isStringValue_Distribution `protobuf_oneof:"distribution"`
}

func (m *StringValue) Reset()                    { *m = StringValue{} }
func (m *StringValue) String() string            { return proto.CompactTextString(m) }
func (*StringValue) ProtoMessage()               {}
func (*StringValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type isStringValue_Distribution interface {
	isStringValue_Distribution()
}

type StringValue_List struct {
	List *StringList `protobuf:"bytes,2,opt,name=list,oneof"`
}

func (*StringValue_List) isStringValue_Distribution() {}

func (m *StringValue) GetDistribution() isStringValue_Distribution {
	if m != nil {
		return m.Distribution
	}
	return nil
}

func (m *StringValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *StringValue) GetList() *StringList {
	if x, ok := m.GetDistribution().(*StringValue_List); ok {
		return x.List
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StringValue) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StringValue_OneofMarshaler, _StringValue_OneofUnmarshaler, _StringValue_OneofSizer, []interface{}{
		(*StringValue_List)(nil),
	}
}

func _StringValue_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StringValue)
	// distribution
	switch x := m.Distribution.(type) {
	case *StringValue_List:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.List); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StringValue.Distribution has unexpected type %T", x)
	}
	return nil
}

func _StringValue_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StringValue)
	switch tag {
	case 2: // distribution.list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringList)
		err := b.DecodeMessage(msg)
		m.Distribution = &StringValue_List{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StringValue_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StringValue)
	// distribution
	switch x := m.Distribution.(type) {
	case *StringValue_List:
		s := proto.Size(x.List)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type StringList struct {
	// The set of strings which can be used.
	Options []string `protobuf:"bytes,1,rep,name=options" json:"options,omitempty"`
	// Set to true to randomize selection of value from options. If false, the
	// values are cycled in order, starting at index 0.
	Random bool `protobuf:"varint,2,opt,name=random" json:"random,omitempty"`
}

func (m *StringList) Reset()                    { *m = StringList{} }
func (m *StringList) String() string            { return proto.CompactTextString(m) }
func (*StringList) ProtoMessage()               {}
func (*StringList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *StringList) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *StringList) GetRandom() bool {
	if m != nil {
		return m.Random
	}
	return false
}

func init() {
	proto.RegisterType((*Configuration)(nil), "telemetry.proxy.fake.Configuration")
	proto.RegisterType((*Credentials)(nil), "telemetry.proxy.fake.Credentials")
	proto.RegisterType((*Config)(nil), "telemetry.proxy.fake.Config")
	proto.RegisterType((*DeleteValue)(nil), "telemetry.proxy.fake.DeleteValue")
	proto.RegisterType((*Value)(nil), "telemetry.proxy.fake.Value")
	proto.RegisterType((*Timestamp)(nil), "telemetry.proxy.fake.Timestamp")
	proto.RegisterType((*IntValue)(nil), "telemetry.proxy.fake.IntValue")
	proto.RegisterType((*IntRange)(nil), "telemetry.proxy.fake.IntRange")
	proto.RegisterType((*IntList)(nil), "telemetry.proxy.fake.IntList")
	proto.RegisterType((*DoubleValue)(nil), "telemetry.proxy.fake.DoubleValue")
	proto.RegisterType((*DoubleRange)(nil), "telemetry.proxy.fake.DoubleRange")
	proto.RegisterType((*DoubleList)(nil), "telemetry.proxy.fake.DoubleList")
	proto.RegisterType((*StringValue)(nil), "telemetry.proxy.fake.StringValue")
	proto.RegisterType((*StringList)(nil), "telemetry.proxy.fake.StringList")
	proto.RegisterEnum("telemetry.proxy.fake.State", State_name, State_value)
	proto.RegisterEnum("telemetry.proxy.fake.Config_ClientType", Config_ClientType_name, Config_ClientType_value)
}

func init() { proto.RegisterFile("fake.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 871 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x96, 0x4f, 0x8f, 0xda, 0x46,
	0x14, 0xc0, 0x19, 0x0c, 0x06, 0x3f, 0xef, 0xae, 0xd0, 0x68, 0x55, 0x59, 0x49, 0xda, 0x10, 0x5f,
	0x8a, 0x5a, 0x89, 0x03, 0x5b, 0x45, 0xaa, 0xa2, 0x44, 0xda, 0x05, 0xba, 0x20, 0x75, 0xc9, 0x6a,
	0x20, 0x95, 0x7a, 0x42, 0xb3, 0x78, 0x20, 0x56, 0xb0, 0x8d, 0xec, 0x21, 0x05, 0xf5, 0xb3, 0xf4,
	0xda, 0x4b, 0x4f, 0xfd, 0x3a, 0xfd, 0x34, 0xd5, 0x3c, 0x8f, 0xb1, 0x59, 0xb1, 0xce, 0x21, 0xb7,
	0xf7, 0xff, 0x3d, 0xff, 0xde, 0x1b, 0x76, 0x01, 0x96, 0xfc, 0x93, 0xe8, 0x6e, 0xe2, 0x48, 0x46,
	0xf4, 0x52, 0x8a, 0xb5, 0x08, 0x84, 0x8c, 0xf7, 0xca, 0xb0, 0xdb, 0x77, 0x95, 0xcf, 0x1d, 0xc2,
	0x79, 0x3f, 0x0a, 0x97, 0xfe, 0x6a, 0x1b, 0x73, 0xe9, 0x47, 0x21, 0xfd, 0x09, 0xcc, 0x05, 0x1a,
	0x1c, 0xd2, 0x36, 0x3a, 0x76, 0xef, 0x45, 0xf7, 0x54, 0x5e, 0x37, 0x4d, 0x62, 0x3a, 0xd6, 0x1d,
	0x82, 0xdd, 0x8f, 0x85, 0x27, 0x42, 0xe9, 0xf3, 0x75, 0x42, 0x9f, 0x41, 0x73, 0x9b, 0x88, 0x38,
	0xe4, 0x81, 0x70, 0x48, 0x9b, 0x74, 0x2c, 0x76, 0xd0, 0x95, 0x6f, 0xc3, 0x93, 0xe4, 0x8f, 0x28,
	0xf6, 0x9c, 0x6a, 0xea, 0xcb, 0x74, 0xf7, 0x1f, 0x03, 0xcc, 0xb4, 0x32, 0xfd, 0x06, 0x4c, 0xc9,
	0xe3, 0x95, 0x90, 0xba, 0x80, 0xd6, 0x28, 0x85, 0xda, 0x26, 0x8a, 0x25, 0xa6, 0x1a, 0x0c, 0x65,
	0x65, 0x4b, 0x84, 0xf0, 0x1c, 0x33, 0xb5, 0x29, 0x99, 0x5e, 0x81, 0xf9, 0x99, 0xaf, 0xb7, 0x22,
	0x71, 0x0c, 0xfc, 0x8e, 0xe7, 0xa7, 0xbf, 0xe3, 0x37, 0x15, 0xc3, 0x74, 0x28, 0x7d, 0x05, 0x67,
	0x9e, 0x9f, 0xf0, 0x87, 0xb5, 0x98, 0x27, 0xfb, 0x70, 0xe1, 0xd4, 0xda, 0xa4, 0xd3, 0x64, 0xb6,
	0xb6, 0x4d, 0xf7, 0xe1, 0x82, 0x8e, 0xc0, 0x5e, 0xac, 0x7d, 0x11, 0xca, 0xb9, 0xdc, 0x6f, 0x84,
	0x53, 0x6f, 0x93, 0xce, 0x45, 0xef, 0xfb, 0x32, 0x48, 0xdd, 0x3e, 0xc6, 0xcf, 0xf6, 0x1b, 0xc1,
	0x60, 0x71, 0x90, 0xe9, 0x4b, 0xc8, 0x0a, 0xcf, 0x45, 0xb4, 0x74, 0x1a, 0xd8, 0x0b, 0xb4, 0x69,
	0x18, 0x2d, 0x69, 0x1f, 0xec, 0x45, 0x0e, 0xd5, 0x69, 0xb6, 0x49, 0xc7, 0xee, 0xbd, 0x7a, 0xa2,
	0x55, 0x1e, 0xc8, 0x8a, 0x59, 0x8a, 0xcd, 0x42, 0xc4, 0xd2, 0xb1, 0xda, 0xa4, 0x73, 0xc6, 0x50,
	0x76, 0x87, 0x00, 0xf9, 0x4c, 0xb4, 0x09, 0xb5, 0x5b, 0x76, 0xdf, 0x6f, 0x55, 0x28, 0x80, 0x39,
	0x9d, 0x7d, 0xb8, 0xb9, 0xf9, 0xbd, 0x45, 0xe8, 0x39, 0x58, 0xca, 0x3a, 0xbf, 0x9d, 0xdc, 0x8d,
	0x5b, 0x55, 0x4a, 0xe1, 0xe2, 0xa0, 0xce, 0xef, 0xd9, 0xfb, 0x41, 0xcb, 0x70, 0xcf, 0xc1, 0x1e,
	0x88, 0xb5, 0x90, 0x02, 0x21, 0xba, 0xff, 0x1a, 0x50, 0x47, 0x09, 0x77, 0xc4, 0xe5, 0x47, 0xbc,
	0x20, 0x8b, 0xa1, 0x4c, 0xdf, 0x82, 0x25, 0xfd, 0x40, 0x24, 0x92, 0x07, 0x1b, 0x5c, 0x9e, 0xdd,
	0x7b, 0x79, 0xfa, 0x53, 0x66, 0x59, 0x18, 0xcb, 0x33, 0xd4, 0x39, 0xc4, 0x62, 0x23, 0xb8, 0xc4,
	0x25, 0xd7, 0x99, 0xd6, 0x0e, 0xab, 0x6f, 0x14, 0x56, 0xff, 0x16, 0x2c, 0x3f, 0x94, 0x73, 0xdc,
	0xa9, 0xe3, 0x61, 0xab, 0xef, 0x4e, 0xb7, 0x1a, 0x87, 0x12, 0x27, 0x1e, 0x55, 0x58, 0xd3, 0xd7,
	0x32, 0xfd, 0x05, 0xce, 0xbc, 0x68, 0xab, 0xd6, 0x92, 0x56, 0x10, 0x65, 0xdc, 0x07, 0x18, 0x99,
	0x15, 0xb1, 0xbd, 0x5c, 0x55, 0x75, 0x12, 0x19, 0xfb, 0xe1, 0x4a, 0xd7, 0x59, 0x96, 0xd5, 0x99,
	0x62, 0xe4, 0xa1, 0x4e, 0x92, 0xab, 0xf4, 0x12, 0x6a, 0x78, 0x8c, 0xab, 0x36, 0xe9, 0xd4, 0x46,
	0x15, 0x86, 0x1a, 0x7d, 0x03, 0xa6, 0x87, 0xf0, 0x9d, 0x8f, 0xa5, 0xf3, 0xe5, 0x0b, 0x1a, 0x55,
	0x98, 0x4e, 0xb9, 0x69, 0x40, 0x1d, 0x67, 0x72, 0x17, 0x60, 0x1d, 0x70, 0xd3, 0x17, 0xc5, 0x15,
	0x11, 0x04, 0x5a, 0xd8, 0xc0, 0x73, 0xb0, 0x3c, 0xb1, 0x96, 0x7c, 0x1e, 0xf8, 0xa1, 0x7e, 0x7d,
	0x4d, 0x34, 0xdc, 0xf9, 0x61, 0xc1, 0xc9, 0x77, 0x8e, 0x51, 0x74, 0xf2, 0x9d, 0xfb, 0x17, 0x81,
	0x66, 0x46, 0x9a, 0x5e, 0xea, 0xd6, 0xba, 0x41, 0xaa, 0xd0, 0xd7, 0x50, 0x8f, 0x79, 0xb8, 0x12,
	0xfa, 0x32, 0x9e, 0x5e, 0x17, 0x53, 0x51, 0xa3, 0x0a, 0x4b, 0xc3, 0xe9, 0x15, 0xd4, 0xd6, 0x7e,
	0x22, 0xb1, 0xa5, 0xdd, 0xfb, 0xf6, 0xc9, 0xb4, 0x5f, 0xfd, 0x44, 0x2a, 0x74, 0x2a, 0xf8, 0xe6,
	0x02, 0x5f, 0xb9, 0x8c, 0xfd, 0x87, 0xad, 0xfa, 0xc9, 0x73, 0x77, 0x38, 0x1e, 0x56, 0xa6, 0x0e,
	0x34, 0x02, 0x3f, 0xf4, 0x83, 0x6d, 0xa0, 0x07, 0xcc, 0x54, 0xf4, 0xf0, 0x1d, 0x7a, 0xaa, 0xda,
	0x93, 0xaa, 0xc7, 0x64, 0x8c, 0x32, 0x32, 0xb5, 0x47, 0x64, 0xde, 0x40, 0x43, 0x0f, 0xa7, 0xca,
	0x47, 0x1b, 0x35, 0x4e, 0x82, 0xcf, 0xc6, 0x60, 0x99, 0x8a, 0xa7, 0xcf, 0x43, 0x2f, 0x4a, 0xfb,
	0x36, 0x99, 0xd6, 0xdc, 0xbf, 0x09, 0xd8, 0x85, 0xf3, 0x3b, 0x26, 0x4b, 0x32, 0xb2, 0x3f, 0x1f,
	0x93, 0x2d, 0x3d, 0xe3, 0x47, 0x70, 0x5f, 0x1f, 0xc1, 0x6d, 0x97, 0x65, 0x96, 0xf2, 0xfd, 0x33,
	0x9b, 0xf3, 0x24, 0x62, 0xf2, 0x24, 0x62, 0x52, 0x82, 0x98, 0x94, 0x21, 0x26, 0x05, 0xc4, 0xef,
	0x00, 0xf2, 0x11, 0x1f, 0x53, 0x26, 0x5f, 0xa6, 0xfc, 0x09, 0xec, 0xe9, 0xd1, 0x63, 0x2c, 0x40,
	0xb6, 0xf2, 0xf3, 0x4d, 0x49, 0x55, 0xcb, 0x48, 0xa5, 0x65, 0x4a, 0x49, 0xbd, 0x03, 0xc8, 0xa3,
	0x1e, 0x0f, 0x6b, 0x7d, 0x71, 0xd8, 0x1f, 0x7e, 0x84, 0xfa, 0x54, 0x72, 0x29, 0xa8, 0x0d, 0x8d,
	0xe9, 0xec, 0xfd, 0xfd, 0xfd, 0x70, 0xd0, 0xaa, 0xa8, 0x1f, 0xf8, 0xf1, 0x64, 0x3c, 0x6b, 0x11,
	0x65, 0x66, 0x1f, 0x26, 0x93, 0xf1, 0xe4, 0xb6, 0x55, 0xed, 0xfd, 0x47, 0xe0, 0xec, 0x7a, 0x25,
	0x42, 0x79, 0xc7, 0x43, 0xbe, 0x12, 0x31, 0xbd, 0x06, 0xe3, 0xda, 0xf3, 0x68, 0xe9, 0x5f, 0xfc,
	0x67, 0xa5, 0x5e, 0x3a, 0x00, 0x93, 0x89, 0x20, 0xfa, 0x2c, 0xbe, 0xaa, 0xca, 0x35, 0x18, 0xb7,
	0x42, 0x7e, 0x4d, 0x89, 0x07, 0x13, 0xff, 0xe9, 0xb9, 0xfa, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x6a,
	0xad, 0xfd, 0x03, 0x02, 0x09, 0x00, 0x00,
}
